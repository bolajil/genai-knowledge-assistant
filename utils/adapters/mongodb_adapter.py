"""\nMongoDB Vector Store Adapter\nImplements vector search using MongoDB with Atlas Vector Search\n"""\n\nimport json\nimport logging\nfrom typing import List, Dict, Any, Optional, Tuple\nfrom datetime import datetime\n\ntry:\n    import pymongo\n    from pymongo import MongoClient\n    from pymongo.errors import ConnectionFailure, OperationFailure\n    import numpy as np\n    MONGODB_AVAILABLE = True\nexcept ImportError:\n    MONGODB_AVAILABLE = False\n    # Create mock classes for type hints when pymongo is not available\n    class MongoClient:\n        pass\n    \n    class pymongo:\n        pass\n    \n    import numpy as np\n\nfrom ..multi_vector_storage_interface import (\n    BaseVectorStore, VectorStoreConfig, VectorSearchResult, VectorStoreType, \n    VectorStoreFactory\n)\n\nlogger = logging.getLogger(__name__)\n\nclass MongoDBAdapter(BaseVectorStore):\n    """MongoDB with Atlas Vector Search implementation"""\n    \n    def __init__(self, config: VectorStoreConfig):\n        super().__init__(config)\n        \n        if not MONGODB_AVAILABLE:\n            raise ImportError("pymongo package is required for MongoDB adapter")\n        \n        # Extract connection parameters\n        params = config.connection_params\n        self.connection_string = params.get('connection_string', '')\n        self.username = params.get('username', 'vaultmind')  # Default to vaultmind as requested\n        self.password = params.get('password', '')\n        self.host = params.get('host', 'localhost')\n        self.port = params.get('port', 27017)\n        self.database_name = params.get('database', 'vaultmind')\n        \n        # Vector configuration\n        self.vector_dimension = params.get('vector_dimension', 384)\n        self.index_name = params.get('index_name', 'vector_index')\n        \n        self._client = None\n        self._db = None\n    \n    def _build_connection_string(self) -> str:\n        """Build MongoDB connection string if not provided"""\n        if self.connection_string:\n            return self.connection_string\n            \n        auth_part = f"{self.username}:{self.password}@" if self.username and self.password else ""\n        return f"mongodb://{auth_part}{self.host}:{self.port}/{self.database_name}"\n    \n    async def connect(self) -> bool:\n        """Establish connection to MongoDB"""\n        try:\n            connection_string = self._build_connection_string()\n            self._client = MongoClient(connection_string)\n            \n            # Test connection\n            self._client.admin.command('ping')\n            \n            # Set database\n            self._db = self._client[self.database_name]\n            \n            self._connected = True\n            logger.info(f"Connected to MongoDB: {self.host}:{self.port}/{self.database_name}")\n            return True\n            \n        except (ConnectionFailure, OperationFailure) as e:\n            self._connected = False\n            logger.error(f"Failed to connect to MongoDB: {e}")\n            return False\n        except Exception as e:\n            self._connected = False\n            logger.error(f"Unexpected error connecting to MongoDB: {e}")\n            return False\n    \n    async def disconnect(self) -> None:\n        """Close connection to MongoDB"""\n        if self._client:\n            self._client.close()\n            self._client = None\n            self._db = None\n            self._connected = False\n            logger.info("Disconnected from MongoDB")\n    \n    async def create_collection(self, collection_name: str, **kwargs) -> bool:\n        """Create a new collection"""\n        try:\n            if not self._connected or not self._db:\n                await self.connect()\n                \n            # Create collection if it doesn't exist\n            if collection_name not in self._db.list_collection_names():\n                self._db.create_collection(collection_name)\n                \n            # Create vector search index if specified\n            create_index = kwargs.get('create_index', True)\n            if create_index:\n                # Define the vector search index\n                index_definition = {\n                    "mappings": {\n                        "dynamic": True,\n                        "fields": {\n                            "embedding": {\n                                "dimensions": self.vector_dimension,\n                                "similarity": "cosine",\n                                "type": "knnVector"\n                            }\n                        }\n                    }\n                }\n                \n                # Create the index\n                self._db.command(\n                    "createSearchIndex",\n                    collection_name,\n                    name=self.index_name,\n                    definition=index_definition\n                )\n                \n            logger.info(f"Created MongoDB collection: {collection_name}")\n            return True\n            \n        except Exception as e:\n            logger.error(f"Failed to create MongoDB collection {collection_name}: {e}")\n            return False\n    \n    async def delete_collection(self, collection_name: str) -> bool:\n        """Delete a collection"""\n        try:\n            if not self._connected or not self._db:\n                await self.connect()\n                \n            if collection_name in self._db.list_collection_names():\n                self._db.drop_collection(collection_name)\n                logger.info(f"Deleted MongoDB collection: {collection_name}")\n                return True\n            return False\n            \n        except Exception as e:\n            logger.error(f"Failed to delete MongoDB collection {collection_name}: {e}")\n            return False\n    \n    async def list_collections(self) -> List[str]:\n        """List all available collections"""\n        try:\n            if not self._connected or not self._db:\n                await self.connect()\n                \n            return self._db.list_collection_names()\n            \n        except Exception as e:\n            logger.error(f"Failed to list MongoDB collections: {e}")\n            return []\n    \n    async def upsert_documents(self, \n                             collection_name: str,\n                             documents: List[Dict[str, Any]],\n                             embeddings: Optional[List[List[float]]] = None) -> bool:\n        """Insert or update documents in the collection"""\n        try:\n            if not self._connected or not self._db:\n                await self.connect()\n                \n            collection = self._db[collection_name]\n            \n            # Prepare documents with embeddings\n            docs_to_insert = []\n            for i, doc in enumerate(documents):\n                doc_copy = doc.copy()\n                \n                # Add embedding if provided\n                if embeddings and i < len(embeddings):\n                    doc_copy['embedding'] = embeddings[i]\n                    \n                # Ensure document has an ID\n                if '_id' not in doc_copy and 'id' in doc_copy:\n                    doc_copy['_id'] = doc_copy['id']\n                    \n                # Add timestamp\n                doc_copy['timestamp'] = datetime.utcnow()\n                \n                docs_to_insert.append(doc_copy)\n            \n            # Use bulk operations for efficiency\n            if docs_to_insert:\n                operations = []\n                for doc in docs_to_insert:\n                    doc_id = doc.get('_id')\n                    if doc_id:\n                        # Update if exists, insert if not\n                        operations.append(\n                            pymongo.UpdateOne(\n                                {'_id': doc_id},\n                                {'$set': doc},\n                                upsert=True\n                            )\n                        )\n                    else:\n                        # Just insert\n                        operations.append(pymongo.InsertOne(doc))\n                \n                if operations:\n                    collection.bulk_write(operations)\n                    \n            logger.info(f"Upserted {len(docs_to_insert)} documents to MongoDB collection {collection_name}")\n            return True\n            \n        except Exception as e:\n            logger.error(f"Failed to upsert documents to MongoDB collection {collection_name}: {e}")\n            return False\n    \n    async def search(self, \n                    collection_name: str,\n                    query: Optional[str] = None,\n                    query_embedding: Optional[List[float]] = None,\n                    filters: Optional[Dict[str, Any]] = None,\n                    limit: int = 10,\n                    **kwargs) -> List[VectorSearchResult]:\n        """Search for similar documents using vector search"""\n        try:\n            if not self._connected or not self._db:\n                await self.connect()\n                \n            collection = self._db[collection_name]\n            \n            if not query_embedding:\n                logger.error("Query embedding is required for MongoDB vector search")\n                return []\n            \n            # Build the vector search pipeline\n            pipeline = [\n                {\n                    "$search": {\n                        "index": self.index_name,\n                        "knnBeta": {\n                            "vector": query_embedding,\n                            "path": "embedding",\n                            "k": limit\n                        }\n                    }\n                },\n                {\n                    "$project": {\n                        "_id": 0,\n                        "content": 1,\n                        "metadata": 1,\n                        "score": {"$meta": "searchScore"}\n                    }\n                }\n            ]\n            \n            # Add filters if provided\n            if filters:\n                match_stage = {"$match": filters}\n                pipeline.insert(1, match_stage)\n            \n            # Execute the search\n            results = list(collection.aggregate(pipeline))\n            \n            # Convert to standard format\n            vector_results = []\n            for result in results:\n                # Extract content and metadata\n                content = result.get('content', '')\n                metadata = result.get('metadata', {})\n                score = result.get('score', 0.0)\n                \n                # Create standardized result\n                vector_result = VectorSearchResult(\n                    content=content,\n                    metadata=metadata,\n                    score=score,\n                    source=collection_name,\n                    id=str(result.get('_id', ''))\n                )\n                vector_results.append(vector_result)\n            \n            return vector_results\n            \n        except Exception as e:\n            logger.error(f"Failed to search MongoDB collection {collection_name}: {e}")\n            return []\n    \n    async def delete_documents(self, \n                             collection_name: str,\n                             document_ids: List[str]) -> bool:\n        """Delete specific documents from collection"""\n        try:\n            if not self._connected or not self._db:\n                await self.connect()\n                \n            collection = self._db[collection_name]\n            \n            # Delete documents by ID\n            result = collection.delete_many({'_id': {'$in': document_ids}})\n            \n            logger.info(f"Deleted {result.deleted_count} documents from MongoDB collection {collection_name}")\n            return True\n            \n        except Exception as e:\n            logger.error(f"Failed to delete documents from MongoDB collection {collection_name}: {e}")\n            return False\n    \n    async def get_collection_stats(self, collection_name: str) -> Dict[str, Any]:\n        """Get statistics about a collection"""\n        try:\n            if not self._connected or not self._db:\n                await self.connect()\n                \n            collection = self._db[collection_name]\n            \n            # Get basic stats\n            count = collection.count_documents({})\n            \n            # Get index information\n            indexes = list(collection.list_indexes())\n            index_names = [idx.get('name') for idx in indexes]\n            \n            return {\n                "count": count,\n                "indexes": index_names,\n                "vector_index": self.index_name in index_names\n            }\n            \n        except Exception as e:\n            logger.error(f"Failed to get stats for MongoDB collection {collection_name}: {e}")\n            return {"error": str(e)}\n    \n    async def health_check(self) -> Tuple[bool, str]:\n        """Check if MongoDB is healthy"""\n        try:\n            if not self._connected:\n                await self.connect()\n                \n            if not self._connected:\n                return False, "Not connected to MongoDB"\n                \n            # Ping the server\n            self._client.admin.command('ping')\n            \n            # List databases as a further check\n            self._client.list_database_names()\n            \n            return True, "MongoDB connection is healthy"\n            \n        except Exception as e:\n            return False, f"MongoDB health check failed: {e}"\n\n# Register the adapter with the factory\nif MONGODB_AVAILABLE:\n    # Add MongoDB to VectorStoreType enum if not already there\n    if not hasattr(VectorStoreType, 'MONGODB'):\n        VectorStoreType.MONGODB = "mongodb"\n        \n    # Register the adapter\n    VectorStoreFactory.register(VectorStoreType.MONGODB, MongoDBAdapter)\n    logger.info("Registered MongoDB adapter")\nelse:\n    logger.warning("MongoDB adapter not registered: pymongo not available")\n"}}}